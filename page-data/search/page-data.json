{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/14502\n\n## 해설\n바이러스가 최대한 덜 퍼지도록 연구소에 벽을 3개 세워서 안전 영역의 최대 크기를 구하는 문제입니다.\n바이러스가 퍼지는 과정은 BFS를 사용하면 됩니다.\n\n### 시간복잡도 계산\n$3 \\leq N, M \\leq 8$에서 N*M 크기의 연구소에 벽을 3개 세우는데 $(N \\times M)^3$가 소요되고 바이러스가 퍼지는데 $N \\times M$가 걸리므로, 최대 uptime은 $(N \\times M)^3 \\times N \\times M \\leq 10^{18}$ 입니다.\n따라서 단순히 BFS와 Brute-force를 사용할 수 있습니다.\n\n### 구현\n입력을 받을 때, 바이러스의 위치는 따로 저장해 둡니다.\n\nBrute-force로 가능한 모든 위치에 벽을 세웁니다. 이 때, 세웠던 벽을 다시 없애는 부분에 주의해야 합니다.\n\n바이러스의 위치에서부터 BFS로 상하좌우 4방향으로 이동합니다. 이 때, 아직 방문하지 않은 위치에 도착했다면 안전 영역의 범위를 감소시킵니다.\n\n## 소스 코드\nhttp://boj.kr/dc1bb71636ce4fbb9bc7b25e239704f0\n\n---\n\n## 참고","excerpt":"문제 https://www.acmicpc.net/problem/14502 해설 바이러스가 최대한 덜 퍼지도록 연구소에 벽을 3개 세워서 안전 영역의 최대 크기를 구하는 문제입니다.\n바이러스가 퍼지는 과정은 BFS…","fields":{"slug":"/boj-14502/"},"frontmatter":{"date":"Apr 13, 2020","title":"백준 14502번 - 연구소","tags":["Algorithmn","PS","BOJ","Brute-force","DFS","BFS"]}}},{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/15683\n\n## 해설\n5종류의 CCTV를 적절히 회전해서 CCTV 사각지대의 최소 크기를 구하는 문제입니다. <br>\n각 CCTV가 한 번에 볼 수 있는 방향은 다음과 같습니다.\n- 1번 : 1방향\n- 2번 : 180° 간격으로 2방향\n- 3번 : 90° 간격으로 2방향\n- 4번 : 90° 간격으로 3방향\n- 5번 : 90° 간격으로 4방향\n\nCCTV는 90° 간격으로만 회전할 수 있으며, CCTV는 통과해서 볼 수 있지만 벽 너머는 보지 못합니다.\n\n### 시간복잡도 계산\n최대 8개의 CCTV가 있고, 각 CCTV를 4방향으로 회전하는데 최대 $4^8 = 65536$ 가 소요됩니다. 각각의 바라본 방향으로 확인을 하는데 최대 $max(N, M) \\times 4$ 가 소요됩니다. $1 \\leq N, M \\leq 8$ 이므로, 총 uptime은 $65536 \\times max(N, M) \\times 4$ 입니다. 따라서 단순히 Brute-force로도 충분히 해결 가능합니다.\n\n### 구현\n입력을 받을 때, CCTV의 위치와 종류는 따로 저장해둡니다.\n\n먼저, 각 CCTV에 대하여 4방향으로 회전시켰을 때 visit 배열을 사용해서 볼 수 있는 범위를 체크합니다. 모든 CCTV를 배치했을 때 사각지대의 크기를 확인한 뒤, 체크했던 visit 배열을 되돌립니다.\n\n여기서 CCTV가 볼 수 있는 방향을 bitmask로 vector에 정의해두면 편리합니다.\n\n## 소스 코드\nhttp://boj.kr/asdfghjkl1234567890\n\n## 코멘트\nBitmasking에 좀 더 친숙해져야겠습니다. 5종류의 CCTV 시야를 구현하는 아이디어를 떠올리는데 쉽지 않았습니다.\n\n---\n\n## 참고","excerpt":"문제 https://www.acmicpc.net/problem/15683 해설 5종류의 CCTV를 적절히 회전해서 CCTV 사각지대의 최소 크기를 구하는 문제입니다. \n각 CCTV가 한 번에 볼 수 있는 방향은 다음과 같습니다. 1번 : 1방향…","fields":{"slug":"/boj-15683/"},"frontmatter":{"date":"Apr 13, 2020","title":"백준 15683번 - 감시","tags":["Algorithmn","PS","BOJ","Brute-force"]}}},{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/13460\n\n## 해설\nN*M 크기의 보드를 4방향으로 기울여서, 파란 구슬과 빨간 구슬을 굴려 빨간 구슬만 구멍에 빠지게 하는 최소 횟수를 구하는 문제입니다. 현재 상태에서 4가지 방향으로 기울이는 4가지 경우를 탐색해 나가면 됩니다.\n\n### 시간복잡도 계산\n$3 \\leq N, M \\leq 10$ 이고 4방향으로 최대 10회 탐색하므로, 최대 uptime은 대략 $max(N, M) \\times 4^10 \\leq 10^{18}$ 입니다. 따라서 단순히 BFS와 Brute-force를 사용할 수 있습니다.\n\n### 구현\n입력을 받을 때, 구슬과 구멍의 위치는 따로 저장해 둡니다.\n\n현재 상태를 기준으로\n- 위쪽으로 기울였을 때 변화된 상태\n- 오른쪽으로 기울였을 때 변화된 상태\n- 아래쪽으로 기울였을 때 변화된 상태\n- 왼쪽으로 기울였을 때 변화된 상태\n이 4가지 경우를 BFS로 탐색해 나갈 수 있습니다. 최대 탐색 깊이는 10회 이하로 제한합니다.\n\n1번 기울였을 때, 구슬은 벽이나 구멍을 만나면 더 이상 구르지 않습니다. 따라서\n  * 구슬이 구멍에 빠진 경우\n    * 빨간 구슬이 먼저 구멍에 빠졌다면, 성공\n    * 파란 구슬이 먼저 구멍에 빠졌다면, 실패\n  * 구슬이 벽에 닿은 경우\n    * 빨간 구슬과 파란 구슬이 다른 경로로 굴렀다면, 아무 일도 없음\n    * 빨간 구슬과 파란 구슬이 같은 경로로 굴렀다면, 구슬의 위치를 재조정\n\nvisit 배열을 사용해서 이전 상황과 중복된 위치에 구슬이 있을 경우 제외합니다.\n\n## 소스 코드\nhttp://boj.kr/47d4f461d3b842b2a33bf45952b0ae8a\n\n## 코멘트\n문제 자체는 전형적인 BFS문제지만, 각 경우에 대한 예외처리를 고민하는데 여러 시간이 걸렸습니다... 삼성 코드테스트를 기반으로 한 문제들은 전반적으로 까다로운 구현을 요구하는 것 같습니다.\n침착하게 펜과 종이로 그려보면서 생각하는 것이 도움이 되었습니다.\n\n---\n\n## 참고","excerpt":"문제 https://www.acmicpc.net/problem/13460 해설 N*M 크기의 보드를 4방향으로 기울여서, 파란 구슬과 빨간 구슬을 굴려 빨간 구슬만 구멍에 빠지게 하는 최소 횟수를 구하는 문제입니다. 현재 상태에서…","fields":{"slug":"/boj-13460/"},"frontmatter":{"date":"Apr 12, 2020","title":"백준 13460번 - 구슬 탈출 2","tags":["Algorithmn","PS","BOJ","Brute-force","BFS"]}}},{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/14500\n\n## 해설\n테트로미노를 N*M 종이 위에 하나 두었을 때, 얻을 수 있는 합의 최대를 구해야 합니다. <br>\n문제에서 주어진 테트리미노는 5개이며, 각 테트리미노를 회전하거나 대칭시켜서 만들 수 있는 형태는 총 19가지입니다.\n- I 형태 : 2가지\n- O 형태 : 1가지\n- L 형태 : 8가지\n- S 형태 : 4가지\n- T 형태 : 4가지\n\n### 시간복잡도 계산\n$4 \\leq N,M \\leq 500$ 이므로 최대 uptime은 대략 $19 \\times N \\times M \\times 4 \\leq 10^{18}$ 로, Brute-force로도 충분히 해결 가능합니다.\n\n### 구현\n19가지 경우의 형태를 상대 위치를 사용한 배열로 만들고 이를 모든 위치에 놓아보면서 확인해보면 됩니다.\n\n## 소스 코드\nhttp://boj.kr/9fd593147b794c3ea5b2848f4da39153\n\n---\n\n## 참고\n* [BOJ 14500 · 테트로미노](https://rebas.kr/792) : 그림으로 잘 설명되어 있습니다.","excerpt":"문제 https://www.acmicpc.net/problem/14500 해설 테트로미노를 N*M 종이 위에 하나 두었을 때, 얻을 수 있는 합의 최대를 구해야 합니다. \n문제에서 주어진 테트리미노는…","fields":{"slug":"/boj-14500/"},"frontmatter":{"date":"Apr 12, 2020","title":"백준 14500번 - 테트로미노","tags":["Algorithmn","PS","BOJ","Brute-force"]}}},{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/15686\n\n## 해설\n최대 2N개의 집이 있을 때, 치킨집 중 M개를 선택하여 집들과 치킨집들 사이 _치킨 거리_ 가 최소가 되도록 구하는 문제입니다. _치킨 거리_ 를 구하는 구체적인 방법은 문제에 기술되어 있습니다.\n\n### 시간복잡도 계산\n$2 \\leq N \\leq 50, 1 \\leq M \\leq 13$ 에서 치킨집은 최대 13개 이하고, 집은 최대 2N개입니다.\n$_{13}\\mathrm{C}_{k} \\leq 1716$ 이므로 최대 uptime은 대략 $1716 \\times 2N \\times M \\leq 10^9$ 로, Brute-force로도 충분히 해결 가능합니다.\n\n### 구현\n입력을 받을 때, 집의 위치와 치킨집의 위치는 따로 vector에 저장해둡니다.\n\n`next_permutation`을 활용해 치킨집들 중에 M개를 선택합니다. 각 경우에 대하여 도시의 _치킨 거리_ 를 구합니다.\n\n## 소스 코드\nhttp://boj.kr/f4b17d380737470296f3ee2fca69f1c8\n\n---\n\n## 참고\n* [`next_permutation`을 사용해 조합 구하기](/ps-reference/#next_permutation)\n* 이 문제에서 _치킨 거리_ 라고 부르는 용어는 사실 [맨해튼 거리](https://ko.wikipedia.org/wiki/%EB%A7%A8%ED%95%B4%ED%8A%BC_%EA%B1%B0%EB%A6%AC)입니다.","excerpt":"문제 https://www.acmicpc.net/problem/15686 해설 최대 2N개의 집이 있을 때, 치킨집 중 M…","fields":{"slug":"/boj-15686/"},"frontmatter":{"date":"Apr 12, 2020","title":"백준 15686번 - 치킨 배달","tags":["Algorithmn","PS","BOJ","Brute-force"]}}},{"node":{"rawMarkdownBody":"\n# Headers\n### bit/stdc++.h\n\n```cpp\n#include <bit/stdc++.h>\n```\n<details>\n<summary>코드 보기</summary>\n<div markdown=\"1\">\n\n```cpp\n// cpp includes used for precompiling -*- cpp -*-\n \n// Copyright (C) 2003-2013 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO cpp Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n \n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n \n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n \n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n \n/** @file stdc++.h\n *  This is an implementation file for a precompiled header.\n */\n \n// 17.4.1.2 Headers\n \n// C\n#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n \n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n \n// cpp\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n \n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n```\n\n</div>\n</details>\n\n\n### ios\n```cpp\n#include <ios>\n#import <ios>\n```\n* 숏코딩용. std I/O 정도만 포함.\n\n\n# Functions\n## 원소를 수정하는 함수\n### sort\n\n```cpp\n#include <algorithm>\nvoid sort(begin, end, [comparator]);\n```\n* 컨테이너 오름차순 정렬.\n* O(NlogN)\n\n```cpp\nsort(vec.begin(), vec.end(), [](const &T a, const &T b){\n    return a < b;\n});\n```\n* 람다식을 이용한 사용자 정의 Comparator 사용.\n* *`comp(a, b) == comp(b, a)`이면 에러 발생, a == b일때는 임의의 순서 배정 필요*\n\n```cpp\n#include <functional>\nsort(vec.begin(), vec.end(), greater<T>());\n```\nfuctional 헤더의 greater Comparator를 사용해 **내림차순 정렬**.\n\n```cpp\nbool operator< (const &T a, const &T b) {\n    return a < b;\n}\n\nsort(vec.begin(), vec.end());\n```\n* 사용자 정의 `<`연산자를 사용.\n* *`sort`는 순서 비교에 `<`만 사용*\n\n\n### reverse\n\n```cpp\n#include <algorithm>\nvoid reverse(begin, end);\n```\n* 컨테이너의 순서 역전\n* O(N)\n\n```cpp(\nreverse(vec.begin(), vec.end());\n```\n\n\n### unique\n\n```cpp\n#include <algorithm>\nT *iter = unique(begin, end);\n```\n* 컨테이너의 중복 요소를 제거. 제거하고 남은 공간은 쓰레기값으로 남고, 쓰레기값의 시작점 이터레이터를 반환.\n* 정렬과 무관하게 연달아 나온 두 원소 중 하나를 제거.\n* O(N)\n\n```cpp\nvec.erase(unique(vec.begin(), vec.end()), vec.end());\n```\n* 컨테이너에서 중복 요소를 제거하고, 남은 쓰레기값을 삭제.\n\n\n### merge\n> *I have never tasted `merge`.*\n\n\n### fill, fill_n\n\n```cpp\n#include <algorithm>\nvoid fill(begin, end, value);\nvoid fill_n(begin, size, value);\n```\n* 컨테이너의 모든 값에 대입. **다차원 배열 불가능**\n* O(N)\n\n```cpp\nfill(vec.begin(), vec.end(), 375);\nfill_n(vec.begin(), vec.size(), 375);\n```\n\n\n### memset\n\n```cpp\n#include <cstring>\nvoid memset(begin, value, size);\n```\n메* 모리에 값을 셋팅. **다차원 배열 가능**\n\n```cpp\nmemset(arr, 0, size(arr));\n```\n* 배열의 모든 값을 0으로 맵핑. \n\n```cpp\nmemset(arr, -1, size(arr));\n```\n* 배열의 모든 값을 0(0xFF)으로 맵핑.\n\n\n## 탐색 관련 함수\n### find (algorithm)\n\n```cpp\n#include <algorithm>\nT *iter = find(begin, end, value);\n```\n* 컨테이너 안에서 값을 찾고 그 이터레이터를 리턴. **없으면 last를 리턴**.\n* O(N)\n\n```cpp\nint x = *find(vec.begin(), vec.end(), 523);\n```\n\n\n### find (string)\n```cpp\n#include <string>\nsize_t pos = str.find(value, [start]);\n```\n* 문자열 안에서 값을 찾고 그 위치를 리턴. **없으면 string::npos(-1)를 리턴**.\n* O(N)\n\n```cpp\nint p = str.find('a');\n```\n* 단일 문자 `'a'`를 찾고 그 위치를 리턴.\n\n```cpp\nint p = str.find(\"aa\");\n```\n* 문자열 `\"aa\"`를 찾고 그 위치를 리턴.\n\n```cpp\nint p = str.find(\"aa\", start);\n```\n* start번째 문자부터 문자열 `\"aa\"`를 찾고 그 위치를 리턴.\n\n\n### binary_search\n\n```cpp\n#include <algorithm>\nbool include = binary_search(begin, end, value, [comparator]);\n```\n* 정렬된 컨테이너에서 값을 탐색하고 찾았는지를 반환.\n* Comparator는 [`sort`](#sort)와 동일.\n* O(logN)\n\n```cpp\nif (binary_search(vec.begin(), vec.end(), 618))\n  cout << \"Find!\";\n```\n\n\n### lower_bound\n\n```cpp\n#include <algorithm>\nT *iter = lower_bound(begin, end, value, [comparator]);\n```\n* 정렬된 컨테이너에서 이진탐색을 하고 찾은 원소의 이터레이터를 반환, 못 찾으면 value보다 큰 값(다음 위치)의 이터레이터를 반환.\n* $$[0, pivot]$$ 에서 가장 작은 값의 이터레이터.\n* Comparator는 [`sort`](#sort)와 동일.\n* O(logN)\n\n\n### upper_bound\n\n```cpp\n#include <algorithm>\nT *iter = upper_bound(begin, end, value, [comparator]);\n```\n* 정렬된 컨테이너에서 이진탐색을 하고 value를 초과하는 값의 이터레이터를 반환.\n* $$(pivot, N]$$ 에서 가장 작은 값의 이터레이터.\n* Comparator는 [`sort`](#sort)와 동일.\n* O(logN)\n\n\n### equal_range\n\n```cpp\n#include <algorithm>\npair<T*, T*> iterPair = equal_range(begin, end, value, [comparator]);\n```\n* 정렬된 컨테이너에서 이진탐색을 하고 lower_bound와 upper_bound를 pair로 반환.\n* $$[lower\\_bound, upper\\_bound)$$ 범위 이터레이터 리턴.\n* Comparator는 [`sort`](#sort)와 동일.\n* O(logN)\n\n```cpp\nauto p = equal_range(vec.begin(), vec.end(), 762);\ncout << distance(p.first, p.second); // == (p.second - p.first)\n```\n이진탐색을 하고 value와 일치하는 원소의 갯수를 출력. `count(LB ≤ value < RB)`\n\n\n## 수학 관련 함수\n### min, max\n\n```cpp\n#include <algorithm>\nT min(a, b, [comparator]);\nT min(init_list, [comparator]);\nT max(a, b, [comparator]);\nT max(init_list, [comparator]);\n```\n* 매개변수의 최솟값이나 최댓값을 반환.\n* Comparator는 [`sort`](#sort)와 동일.\n\n```cpp\nint mn = min({ 3, 4, 5 });\nint mx = max({ 3, 4, 5 });\n```\n`initializer_list`를 사용하여 최솟값/최댓값 반환.\n\n\n### min&#95;element, max&#95;element\n\n```cpp\n#include <algorithm>\nT *iter = min_element(a, b, [comparator]);\nT *iter = min_element(init_list, [comparator]);\nT *iter = max_element(a, b, [comparator]);\nT *iter = max_element(init_list, [comparator]);\n```\n* 매개변수의 최솟값이나 최댓값의 이터레이터를 반환.\n* Comparator는 [`sort`](#sort)와 동일.\n\n```cpp\nint mn = *min_element({ 3, 4, 5 });\nint mx = *max_element({ 3, 4, 5 });\n```\n`initializer_list`를 사용하여 최솟값/최댓값의 이터레이터를 반환.\n\n\n### ceil, round, floor\n\n```cpp\n#include <cmath>\nT ceil(value);\nT round(value);\nT floor(value);\n```\n* `ceil`: value보다 큰 가장 가까운 정수로 올림\n* `round`: value와 가장 가까운 정수로 반올림\n* `floor`: value보다 작은 가장 가까운 정수로 내림\n\n```cpp\nint H = (int)ceil(log2(N));\nint tree_size = 1 << (H+1);\n```\n`ceil`를 사용하여 트리의 노드 수를 구함.\n\n\n### next_permutation\n\n```cpp\n#include <algorithm>\nbool next_permutation(begin, end, [comparator]);\n```\n* 컨테이너 순열의 다음 번째 순열로 변환, 더 이상 진행할 수 없으면(내림차순 순열이면) `false` 반환.\n* 2종류의 원소만 사용한 배열을 사용하면 조합을 구할 수도 있다.\n* Comparator는 [`sort`](#sort)와 동일.\n\n```cpp\ndo {\n  // ...\n} while (next_permutation(vec.begin(), vec.end()));\n```\n\n```cpp\n// 5C2 구하기\nvector<int> vec(5);\nvector<bool> filter = { false, false, false, true, true };\ndo {\n  for (int i = 0; i < 5; ++i) {\n    if (filter[i]) {\n      // vec[i] is selected.\n    }\n  }\n} while (next_permutation(filter.begin(), filter.end()));\n```\n중복되는 원소를 가진 `filter`의 순열을 구하고, 여기에 대응되는 `vec`의 원소를 선택해서 중복을 허용한다.\n\n\n### prev_permutation\n\n```cpp\n#include <algorithm>\nbool prev_permutation(begin, end, [comparator]);\n```\n* 컨테이너 순열의 이전 번째 순열로 변환, 더 이상 진행할 수 없으면(오름차순 순열이면) `false` 반환.\n* 2종류의 원소만 사용한 배열을 사용하면 조합을 구할 수도 있다.\n* Comparator는 [`sort`](#sort)와 동일.\n\n```cpp\ndo {\n  // ...\n} while (prev_permutation(vec.begin(), vec.end()));\n```\n\n```cpp\n// 5C2 구하기\nvector<int> vec(5);\nvector<bool> filter = { false, false, false, true, true };\ndo {\n  for (int i = 0; i < 5; ++i) {\n    if (filter[i]) {\n      // vec[i] is selected.\n    }\n  }\n} while (prev_permutation(filter.begin(), filter.end()));\n```\n중복되는 원소를 가진 `filter`의 순열을 구하고, 여기에 대응되는 `vec`의 원소를 선택해서 중복을 허용한다.\n\n\n### &#95;&#95;builtin&#95;popcount\n\n```cpp\nunsigned int __builtin_popcount(uint32 value);\n```\n* 32bit unsigned int에 대하여, 1인 bit의 수를 반환.\n* ⚠️ **GCC환경에서만 동작.** ⚠️\n* bitmasking에 대한 더 자세한 내용은 다른 포스트로 추가 예정.\n<!--\n더 공부해보고 정리해서 추가하기\n[Count bits 1 on an integer as fast as GCC __builtin__popcount(int) - Stack Overflow](https://stackoverflow.com/questions/51387998/count-bits-1-on-an-integer-as-fast-as-gcc-builtin-popcountint)\n[마크다운으로 주석 처리 가능](http://www.secmem.org/blog/2019/10/19/handy-function-about-bit/)\n[비트마스크 사용법](https://sunnyholic.com/88)\n-->\n\n\n---\n\nReferences\n* http://www.cplusplus.com/\n* https://en.cppreference.com/","excerpt":"Headers bit/stdc++.h ios 숏코딩용. std I/O 정도만 포함. Functions 원소를 수정하는 함수 sort 컨테이너 오름차순 정렬. O(NlogN) 람다식을 이용한 사용자 정의 Comparator 사용. 이면 에러 발생, a…","fields":{"slug":"/ps-reference/"},"frontmatter":{"date":"Mar 01, 2020","title":"모르면 못푸는 PS용 C++ 레퍼런스","tags":["Algorithmn","PS","STL"]}}},{"node":{"rawMarkdownBody":"\n# 1. Install jenv\n\n```bash\nbrew install jenv\n```\n`brew`를 사용해서 jenv를 설치한다.\n\n\n```bash\nexport PATH=\"$HOME/.jenv/bin:$PATH\"\nif which jenv > /dev/null; then eval \"$(jenv init -)\"; fi\n```\njenv의 환경변수를 설정한다.\n`.bash_profile` 또는 `.zshrc`에 위 코드를 추가한다.\n\n\n```bash\nsource ~/.bash_profile\nsource ~/.zshrc\n```\n`.bash_profile` 또는 `.zshrc`를 실행하여 설정을 적용한다.\n\n\n```bash\njenv enable-plugin export\n```\njenv의 Export plugin을 설정한다.\n`$JAVA_HOME`등의 가상환경으로 연결을 설정한다.\n\n정상적으로 설정이 완료되었다면, `which java`를 했을 때, `$HOME/.jenv/shims/java`로 경로가 나온다.\n\n\n# 2. Install JDK\nJDK를 설치한다.\n`brew`를 사용해도 좋고, Oracle이나 OpenJDK 홈페이지에 접속해서 pkg파일을 다운로드 받은 뒤 설치해도 좋다.\n\n\n# 3. Register JDK to jenv\n```bash\njenv add /Library/Java/JavaVirtualMachines/[JDK version name]/Contents/Home/\n```\n설치한 JDK를 jenv에 등록한다.\n\n# 4. Use jenv\n  * `jenv versions` : 사용할 수 있는 JDK 환경 목록을 보여준다.\n  * `jenv global [JDK version name]` : 선택한 JDK 환경을 기본 설정으로 사용한다.\n  * `jenv local [JDK version name]` : 현재 디렉토리에서만 선택한 JDK 환경을 사용한다.","excerpt":"1. Install jenv 를 사용해서 jenv를 설치한다. jenv의 환경변수를 설정한다.\n 또는 에 위 코드를 추가한다.  또는 를 실행하여 설정을 적용한다. jenv의 Export plugin…","fields":{"slug":"/jenv-on-mac/"},"frontmatter":{"date":"Feb 29, 2020","title":"macOS에서 jenv 사용하기","tags":["Java","macOS"]}}}]}},"pageContext":{}}}