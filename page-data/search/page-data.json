{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/11666\n\n## 해설\n가능한 워크스테이션을 잠금 해제하지 않도록 최적의 스케줄링을 하는 문제입니다. m분이 지나면 자동으로 잠금이 되기 때문에, 이전 연구원이 떠나기 m분 전에 다음 연구원이 사용하도록 배정해주면 됩니다.\n즉, 잠기지 않은 것 중 가장 먼저 연구원이 떠난 (잠기기까지 남은 시간이 가장 짧은) 워크스테이션에 배치하면 최적해를 구할 수 있습니다. \n\n### 시간복잡도 계산\n`priority_queue`를 사용하여 연구원이 떠난 시간을 $O(NlogN)$ 에 구할 수 있습니다. $1 \\leq N \\leq 300000$ 이므로, Greedy 알고리즘을 사용할 수 있습니다.\n\n### 구현\n먼저 연구원이 도착하여 사용하기 시작한 시간 $t_{arrive}$ 로 정렬합니다.\n`priority_queue`에 연구원이 떠난 시간 $t_{leave}$ 를 저장하고 다음 $t_{arrive}$ 과 비교하여\n* $t_{leave} + m < t_{arrive}$ 이면 이미 잠긴 경우 -> `priority_queue`에서 제외\n* $t_{leave} + m >= t_{arrive}$ 이면 아직 잠기지 않은 경우 -> 새로운 연구원 배치\n\n로 해결할 수 있습니다.\n\n## 소스 코드\nhttp://boj.kr/d7d963b5c5064b758b3fe37e74bc67b3\n\n---\n\n## 참고","excerpt":"문제 https://www.acmicpc.net/problem/11666 해설 가능한 워크스테이션을 잠금 해제하지 않도록 최적의 스케줄링을 하는 문제입니다. m분이 지나면 자동으로 잠금이 되기 때문에, 이전 연구원이 떠나기 m…","fields":{"slug":"/boj-11666/"},"frontmatter":{"date":"Jul 08, 2020","title":"백준 11666번 - 워크스테이션 배정","tags":["Algorithmn","PS","BOJ","Greedy"]}}},{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/00000\n\n## 해설\n주어진 숫자 쌍에 3가지 연산자를 적용해서 모두 다른 결과를 내도록 하는 문제입니다.\n*(주어진 숫자 쌍) - (주어진 숫자 쌍의 가능한 모든 연산 결과)* 를 연결한 이분 그래프를 만들고, 이분 매칭을 하면 됩니다. 왼쪽 노드가 모두 연결되면 해당하는 연산식을 사용하면 되고, 연결될 수 없으면 문제를 해결할 수 없습니다.\n![boj11670.png](boj11670.png)\n\n### 시간복잡도 계산\nDFS를 사용한 이분 매칭의 시간복잡도는 $O(V \\times E)$ 입니다. 여기서 V는 숫자 쌍의 갯수인 n이고, 연산자가 3가지이므로 E는 3n입니다.\n$1 \\leq n \\leq 2500$ 이므로 이분 매칭으로 제한 시간 안에 해결할 수 있습니다.\n\n### 구현\n정석적인 이분 매칭입니다.\n\n## 소스 코드\nhttp://boj.kr/8d632e8516e64d75ac6c187ee2c8734f\n\n---\n\n## 참고","excerpt":"문제 https://www.acmicpc.net/problem/00000 해설 주어진 숫자 쌍에…","fields":{"slug":"/boj-11670/"},"frontmatter":{"date":"Jul 08, 2020","title":"백준 11670번 - 초등 수학","tags":["Algorithmn","PS","BOJ","이분매칭"]}}},{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/11676\n\n## 해설\n셰프가 요리할 수 있는 코스의 경우의 수를 세는 문제입니다. 설명이 복잡해 보이지만 요약하면 아래 그림과 같습니다.\n![boj11676.png](boj11676.png)\n1. 1가지 코스에서 3가지 요리(에피타이저, 주 요리, 디저트)가 나옵니다.\n2. 에피타이저로 나올 수 있는 요리와 주 요리로 나올 수 있는 요리, 디저트로 나올 수 있는 요리는 각각 따로 정해져 있습니다. 이 때, 한 코스에 동시에 나올 수 없는 요리의 쌍이 존재합니다. \n3. 하나의 요리는 한 개 이상의 재료를 사용하고, 같은 재료를 공유하는 요리가 있을 수 있습니다.\n4. 재료마다 브랜드를 선택할 수 있으며, 같은 재료는 같은 브랜드를 사용합니다.\n\n### 시간복잡도 계산\n각 요리의 종류가 25가지 이하이므로( $1 \\leq s, m, d \\leq 25$ ), 모든 경우의 수를 확인하더라도 $25^3 = 15625$ 가지 밖에 되지 않습니다.\n요리를 정했다면 재료는 고정이고, 브랜드는 재료마다 다르므로 곱해주기만 하면 됩니다. 따라서 Brute-force로도 충분히 해결 가능합니다.\n\n### 구현\nBrute-force 구현 자체는 간단하나, Overflow 체크에 주의해야 합니다. 경우의 수가 10^18 초과이면 \"too many\"를 출력하는데, 브랜드의 최대 가짓수가 100가지이므로 최악의 경우에 10^18 * 100을 계산해야 합니다. 이는 `long long`범위를 초과하기 때문에 곱셈을 하기 전에 미리 Overflow가 일어날지 확인해보아야 합니다.\n\n## 소스 코드\nhttp://boj.kr/a3d7744cd3bf4715b8d9e6d24868aa3a\n\n## 코멘트\nDiscription이 알고리즘 난이도에 비해 매우 길어서 힘들었습니다.\n\n---\n\n## 참고\n","excerpt":"문제 https://www.acmicpc.net/problem/11676 해설 셰프가 요리할 수 있는 코스의 경우의 수를 세는 문제입니다. 설명이 복잡해 보이지만 요약하면 아래 그림과 같습니다.\n 1가지 코스에서…","fields":{"slug":"/boj-11676/"},"frontmatter":{"date":"Jul 08, 2020","title":"백준 11676번 - Kitchen Combinatorics","tags":["Algorithmn","PS","BOJ","Brute-force"]}}},{"node":{"rawMarkdownBody":"\nPDF 폼을 채우는 업무를 받았습니다. 대략 600 rows 쯤 되는 데이터를 분류해서 PDF에 채워 넣는 업무였습니다. <br>\n당연히 손으로 일일히 채우기는 불편하기 때문에 Python을 사용해서 자동화를 해보았습니다.\n\n구글링을 해보니 이미 PDF를 다룰 수 있는 다양한 패키지들을 배포하고 있었습니다. 그 중 `pdfrw`를 사용해서 만들어보았습니다.\n\n# Install\n```bash\npip install pdfrw   # Install with pip\nconda install -c conda-forge pdfrw  # or with conda\n```\n\n# Codes\n\n```python\n# pdf.py\nimport pdfrw\n\ndef fill_pdf(input_pdf_path, output_pdf_path, data_dict):\n\ttemplate_pdf = pdfrw.PdfReader(input_pdf_path)\n\n\tannotations = template_pdf.pages[0]['/Annots']\n\tfor annotation in annotations:\n\t\tif annotation['/Subtype'] == '/Widget':\n\t\t\tif annotation['/T']:\n\t\t\t\tkey = annotation['/T'][1:-1]\n\n\t\t\t\tif key in data_dict.keys():\n\t\t\t\t\tannotation.update(pdfrw.PdfDict(AP=f'{key}', V=f'{data_dict[key]}'))\n\n\tpdfrw.PdfWriter().write(output_pdf_path, template_pdf)\n\ndef fill_pdfs(input_pdf_path, output_pdf_path, data_dict_list):\n\tif not isinstance(data_dict_list, list):\n\t\traise Exception('Error: Argument `data_dict_list` must be list.')\n\n\ttemplate_pdf = pdfrw.PdfReader(input_pdf_path)\n\n\tfor page in range(len(template_pdf.pages)):\n\t\tannotations = template_pdf.pages[page]['/Annots']\n\n\t\tfor annotation in annotations:\n\t\t\tif annotation['/Subtype'] == '/Widget':\n\t\t\t\tif annotation['/T']:\n\t\t\t\t\tkey = annotation['/T'][1:-1]\n\n\t\t\t\t\tif key in data_dict_list[page].keys():\n\t\t\t\t\t\tannotation.update(pdfrw.PdfDict(AP=f'{key}', V=f'{data_dict_list[page][key]}'))\n\n\tpdfrw.PdfWriter().write(output_pdf_path, template_pdf)\n\ndef merge_pdf(pdf_path_list, output_pdf_path):\n\twriter = pdfrw.PdfWriter()\n\n\tfor pdf_path in pdf_path_list:\n\t\tpdf = pdfrw.PdfReader(pdf_path)\n\t\twriter.addpages(pdf.pages)\n\n\twriter.write(output_pdf_path)\n```\nPDF의 Field의 이름을 key, 채울 내용을 value로 하는 dictionary를 `raw_data`로 받아서 폼을 완성합니다.\n`fill_pdf`에서 페이지 내에 있는 모든 annotation을 순회하면서 key가 존재하면, value를 넣고 update합니다.\n\n`fill_pdfs`는 여러 페이지의 PDF문서를 채워 넣을 때 사용합니다. `raw_data_list`는 `raw_data`들의 배열로, 배열의 인덱스가 페이지의 인덱스에 대응됩니다.\n\n그리고 저는 1장짜리 템플릿 PDF문서와 같은 포맷으로 데이터를 채워야했기 때문에, `merge_pdf`로 템플릿 PDF문서끼리 여러 번 merge하여 복사했습니다.\n\n\n```python\n# main.py\nfrom pdf import fill_pdf, fill_pdfs, merge_pdf\nimport json\nfrom math import ceil\n\nRAW_DATA = 'data.json'\n\nPDF_TEMPLATE_PATH = 'template.pdf'\nPDF_OUTPUT_PATH = 'output.pdf'\n\n\nwith open(RAW_DATA) as json_file:\n    raw_data = json.load(json_file)\n\n\nmax_page = int(ceil(len(raw_data) / 5.0))  # 1 page당 5 rows\n\ntemplate_path_list = [PDF_TEMPLATE_PATH for x in range(max_page)]\nmerge_pdf(template_path_list, 'temp.pdf')\n\n\ndata_dict_list = []\ndata_dict = {}\nfor idx, data_row in enumerate(raw_data):\n    for key in data_row:\n        data_dict[f'{key}-{(idx+1) % 5}'] = data_row[key]\n\n    if (idx+1) % 5 == 0 or idx == len(appointment_sorted)-1:\n        data_dict_list.append(data_dict)\n\n\nfill_pdfs('temp.pdf', PDF_OUTPUT_PATH, data_dict_list)\n```\n정의한 함수들을 사용해서 완성한 코드입니다. JSON파일에서 raw data를 읽어와서 1페이지 당 5 rows 씩 나눠서 입력을 했습니다. <br>\n제 경우에는 Field 이름이 `name-index`꼴이라 `f'{key}-{(idx+1) % 5}'`로 지정했습니다. 상황에 맞게 for문을 고치면 될 것 같습니다.\n\n\n```python\n# naming.py\nimport pdfrw\n\ndef fill_name_pdf(input_pdf_path, output_pdf_path):\n    template_pdf = pdfrw.PdfReader(input_pdf_path)\n\n\tannotations = template_pdf.pages[0]['/Annots']\n\tfor annotation in annotations:\n\t\tif annotation['/Subtype'] == '/Widget':\n\t\t\tif annotation['/T']:\n\t\t\t\tkey = annotation['/T'][1:-1]\n\n                # Update every fields.\n\t\t\t\tannotation.update(pdfrw.PdfDict(AP=f'{key}', V=f'{key}'))\n\n\tpdfrw.PdfWriter().write(output_pdf_path, template_pdf)\n```\n만약 PDF의 Field의 이름을 모른다면 위와 같은 코드로 확인해볼 수 있습니다.\n폼의 내용으로 해당하는 Field의 이름을 채웁니다.","excerpt":"PDF 폼을 채우는 업무를 받았습니다. 대략 600 rows 쯤 되는 데이터를 분류해서 PDF에 채워 넣는 업무였습니다. \n당연히 손으로 일일히 채우기는 불편하기 때문에 Python을 사용해서 자동화를 해보았습니다. 구글링을 해보니 이미 PDF…","fields":{"slug":"/pdfrw-automation/"},"frontmatter":{"date":"Apr 24, 2020","title":"pdfrw를 사용한 PDF 업무 자동화","tags":["Python","PDF","TaskAutomation"]}}},{"node":{"rawMarkdownBody":"\n한국에서 가장 많이 사용하는 인스턴트 메신저인 카카오톡은 안타깝게도 Ubuntu를 지원하지 않습니다. 따라서 Wine을 사용하여 Windows용 카카오톡 PC를 설치할 수 밖에 없습니다.\n\n나중에 참고할 수 있도록 간단하게 기록을 남깁니다.\n\n# Wine 설치\n\n## 1. 32bit Architecture 설정\n```bash\nsudo dpkg --add-architecture i386\n```\n\n## 2. Apt repository key 다운로드 및 등록\n```bash\nwget -nc https://dl.winehq.org/wine-builds/winehq.key\nsudo apt-key add winehq.key\n```\n\n## 3. Wine repository 등록\n※ Wine 4.5 이상부터는 libfaudio0 패키지가 필요한데, Ubuntu 19.10 이하에서는 제공되지 않습니다. 따라서 `cybermax-dexter/sdl2-backport` PPA를 추가해야합니다. 등록한 PPA들은 **소프트웨어 & 업데이트** 앱에서 기타 소프트웨어 탭에서 관리할 수 있습니다.\n```bash\nsudo apt-add-repository 'deb https://dl.winehq.org/wine-builds/ubuntu/ bionic main'\nsudo add-apt-repository ppa:cybermax-dexter/sdl2-backport\n```\n\n## 4. Wine 설치\n```bash\nsudo apt update\nsudo apt install --install-recommends winehq-stable\n```\n\n## 5. Wine 환경 설정\n혹시 모를 호환성 이슈를 막기 위해 32bit 프로그램만 실행하도록 설정하고 설정파일의 경로를 지정합니다.\n```bash\nmkdir ~/.wine\nWINEARCH=win32 WINEPREFIX=~/.wine LANG=\"ko_KR.UTF-8\" winecfg\n```\n\n**Wine 설정** 윈도우가 열립니다. 상황에 맞게 적절한 옵션을 설정합니다. <br>\n여기서는 화면 해상도를 192dpi로 설정했습니다.\n\n## 6. 한글 폰트 설치\n미리 다운로드 받아둔 `gulim.ttf`를 wine 내부로 복사하고 레지스트리를 편집합니다.\n```bash\ncp gulim.ttf ~/.wine/drive_c/windows/Fonts\nsed -i 's/\"MS Shell Dlg\".*/\"MS Shell Dlg\"=\"Gulim\"/g' ~/.wine/system.reg\nsed -i 's/\"MS Shell Dlg 2\".*/\"MS Shell Dlg 2\"=\"Gulim\"/g' ~/.wine/system.reg\n```\n\n# 카카오톡 설치\n\n## 1. KakaoTalk_Setup.exe 다운로드\nhttps://software.naver.com/software/summary.nhn?softwareId=GWS_000083\n\n## 2. KakaoTalk_Setup.exe 설치\n```bash\nwine KakaoTalk_Setup.exe\n```\n또는 파일탐색기를 열고 exe에 우클릭하여 **Wine Windows Program Loader로 열기**를 선택할 수 있습니다.\n\n이어서 설치를 진행합니다.\n\n## 3. 시스템 트레이 설정\n```bash\nsudo apt install gnome-shell-extension-top-icons-plus\n```\n설치가 끝난 후, **기능 개선** 앱에서 확장 탭을 열고 **Topicons plus**를 활성화합니다.\n\n---\n\n## 참고\n* https://wiki.winehq.org/Wine_User%27s_Guide\n* http://ubuntuhandbook.org/index.php/2020/01/install-wine-5-0-stable-ubuntu-18-04-19-10/\n* https://hiseon.me/linux/ubuntu/ubuntu-kakaotalk/","excerpt":"한국에서 가장 많이 사용하는 인스턴트 메신저인 카카오톡은 안타깝게도 Ubuntu를 지원하지 않습니다. 따라서 Wine을 사용하여 Windows용 카카오톡 PC를 설치할 수 밖에 없습니다. 나중에 참고할 수 있도록 간단하게 기록을 남깁니다. Wine…","fields":{"slug":"/install-kakaotalk/"},"frontmatter":{"date":"Apr 23, 2020","title":"Ubuntu 18.04 에서 카카오톡 설치","tags":["ReferenceDocument","Ubuntu","Wine"]}}},{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/14502\n\n## 해설\n바이러스가 최대한 덜 퍼지도록 연구소에 벽을 3개 세워서 안전 영역의 최대 크기를 구하는 문제입니다.\n바이러스가 퍼지는 과정은 BFS를 사용하면 됩니다.\n\n### 시간복잡도 계산\n$3 \\leq N, M \\leq 8$에서 N*M 크기의 연구소에 벽을 3개 세우는데 $(N \\times M)^3$가 소요되고 바이러스가 퍼지는데 $N \\times M$가 걸리므로, 최대 uptime은 $(N \\times M)^3 \\times N \\times M \\leq 10^{18}$ 입니다.\n따라서 단순히 BFS와 Brute-force를 사용할 수 있습니다.\n\n### 구현\n입력을 받을 때, 바이러스의 위치는 따로 저장해 둡니다.\n\nBrute-force로 가능한 모든 위치에 벽을 세웁니다. 이 때, 세웠던 벽을 다시 없애는 부분에 주의해야 합니다.\n\n바이러스의 위치에서부터 BFS로 상하좌우 4방향으로 이동합니다. 이 때, 아직 방문하지 않은 위치에 도착했다면 안전 영역의 범위를 감소시킵니다.\n\n## 소스 코드\nhttp://boj.kr/dc1bb71636ce4fbb9bc7b25e239704f0\n\n---\n\n## 참고","excerpt":"문제 https://www.acmicpc.net/problem/14502 해설 바이러스가 최대한 덜 퍼지도록 연구소에 벽을 3개 세워서 안전 영역의 최대 크기를 구하는 문제입니다.\n바이러스가 퍼지는 과정은 BFS…","fields":{"slug":"/boj-14502/"},"frontmatter":{"date":"Apr 13, 2020","title":"백준 14502번 - 연구소","tags":["Algorithmn","PS","BOJ","Brute-force","DFS","BFS"]}}},{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/15683\n\n## 해설\n5종류의 CCTV를 적절히 회전해서 CCTV 사각지대의 최소 크기를 구하는 문제입니다. <br>\n각 CCTV가 한 번에 볼 수 있는 방향은 다음과 같습니다.\n- 1번 : 1방향\n- 2번 : 180° 간격으로 2방향\n- 3번 : 90° 간격으로 2방향\n- 4번 : 90° 간격으로 3방향\n- 5번 : 90° 간격으로 4방향\n\nCCTV는 90° 간격으로만 회전할 수 있으며, CCTV는 통과해서 볼 수 있지만 벽 너머는 보지 못합니다.\n\n### 시간복잡도 계산\n최대 8개의 CCTV가 있고, 각 CCTV를 4방향으로 회전하는데 최대 $4^8 = 65536$ 가 소요됩니다. 각각의 바라본 방향으로 확인을 하는데 최대 $max(N, M) \\times 4$ 가 소요됩니다. $1 \\leq N, M \\leq 8$ 이므로, 총 uptime은 $65536 \\times max(N, M) \\times 4$ 입니다. 따라서 단순히 Brute-force로도 충분히 해결 가능합니다.\n\n### 구현\n입력을 받을 때, CCTV의 위치와 종류는 따로 저장해둡니다.\n\n먼저, 각 CCTV에 대하여 4방향으로 회전시켰을 때 visit 배열을 사용해서 볼 수 있는 범위를 체크합니다. 모든 CCTV를 배치했을 때 사각지대의 크기를 확인한 뒤, 체크했던 visit 배열을 되돌립니다.\n\n여기서 CCTV가 볼 수 있는 방향을 bitmask로 vector에 정의해두면 편리합니다.\n\n## 소스 코드\nhttp://boj.kr/asdfghjkl1234567890\n\n## 코멘트\nBitmasking에 좀 더 친숙해져야겠습니다. 5종류의 CCTV 시야를 구현하는 아이디어를 떠올리는데 쉽지 않았습니다.\n\n---\n\n## 참고","excerpt":"문제 https://www.acmicpc.net/problem/15683 해설 5종류의 CCTV를 적절히 회전해서 CCTV 사각지대의 최소 크기를 구하는 문제입니다. \n각 CCTV가 한 번에 볼 수 있는 방향은 다음과 같습니다. 1번 : 1방향…","fields":{"slug":"/boj-15683/"},"frontmatter":{"date":"Apr 13, 2020","title":"백준 15683번 - 감시","tags":["Algorithmn","PS","BOJ","Brute-force"]}}},{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/14500\n\n## 해설\n테트로미노를 N*M 종이 위에 하나 두었을 때, 얻을 수 있는 합의 최대를 구해야 합니다. <br>\n문제에서 주어진 테트리미노는 5개이며, 각 테트리미노를 회전하거나 대칭시켜서 만들 수 있는 형태는 총 19가지입니다.\n- I 형태 : 2가지\n- O 형태 : 1가지\n- L 형태 : 8가지\n- S 형태 : 4가지\n- T 형태 : 4가지\n\n### 시간복잡도 계산\n$4 \\leq N,M \\leq 500$ 이므로 최대 uptime은 대략 $19 \\times N \\times M \\times 4 \\leq 10^{18}$ 로, Brute-force로도 충분히 해결 가능합니다.\n\n### 구현\n19가지 경우의 형태를 상대 위치를 사용한 배열로 만들고 이를 모든 위치에 놓아보면서 확인해보면 됩니다.\n\n## 소스 코드\nhttp://boj.kr/9fd593147b794c3ea5b2848f4da39153\n\n---\n\n## 참고\n* [BOJ 14500 · 테트로미노](https://rebas.kr/792) : 그림으로 잘 설명되어 있습니다.","excerpt":"문제 https://www.acmicpc.net/problem/14500 해설 테트로미노를 N*M 종이 위에 하나 두었을 때, 얻을 수 있는 합의 최대를 구해야 합니다. \n문제에서 주어진 테트리미노는…","fields":{"slug":"/boj-14500/"},"frontmatter":{"date":"Apr 12, 2020","title":"백준 14500번 - 테트로미노","tags":["Algorithmn","PS","BOJ","Brute-force"]}}},{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/13460\n\n## 해설\nN*M 크기의 보드를 4방향으로 기울여서, 파란 구슬과 빨간 구슬을 굴려 빨간 구슬만 구멍에 빠지게 하는 최소 횟수를 구하는 문제입니다. 현재 상태에서 4가지 방향으로 기울이는 4가지 경우를 탐색해 나가면 됩니다.\n\n### 시간복잡도 계산\n$3 \\leq N, M \\leq 10$ 이고 4방향으로 최대 10회 탐색하므로, 최대 uptime은 대략 $max(N, M) \\times 4^10 \\leq 10^{18}$ 입니다. 따라서 단순히 BFS와 Brute-force를 사용할 수 있습니다.\n\n### 구현\n입력을 받을 때, 구슬과 구멍의 위치는 따로 저장해 둡니다.\n\n현재 상태를 기준으로\n- 위쪽으로 기울였을 때 변화된 상태\n- 오른쪽으로 기울였을 때 변화된 상태\n- 아래쪽으로 기울였을 때 변화된 상태\n- 왼쪽으로 기울였을 때 변화된 상태\n이 4가지 경우를 BFS로 탐색해 나갈 수 있습니다. 최대 탐색 깊이는 10회 이하로 제한합니다.\n\n1번 기울였을 때, 구슬은 벽이나 구멍을 만나면 더 이상 구르지 않습니다. 따라서\n  * 구슬이 구멍에 빠진 경우\n    * 빨간 구슬이 먼저 구멍에 빠졌다면, 성공\n    * 파란 구슬이 먼저 구멍에 빠졌다면, 실패\n  * 구슬이 벽에 닿은 경우\n    * 빨간 구슬과 파란 구슬이 다른 경로로 굴렀다면, 아무 일도 없음\n    * 빨간 구슬과 파란 구슬이 같은 경로로 굴렀다면, 구슬의 위치를 재조정\n\nvisit 배열을 사용해서 이전 상황과 중복된 위치에 구슬이 있을 경우 제외합니다.\n\n## 소스 코드\nhttp://boj.kr/47d4f461d3b842b2a33bf45952b0ae8a\n\n## 코멘트\n문제 자체는 전형적인 BFS문제지만, 각 경우에 대한 예외처리를 고민하는데 여러 시간이 걸렸습니다... 삼성 코드테스트를 기반으로 한 문제들은 전반적으로 까다로운 구현을 요구하는 것 같습니다.\n침착하게 펜과 종이로 그려보면서 생각하는 것이 도움이 되었습니다.\n\n---\n\n## 참고","excerpt":"문제 https://www.acmicpc.net/problem/13460 해설 N*M 크기의 보드를 4방향으로 기울여서, 파란 구슬과 빨간 구슬을 굴려 빨간 구슬만 구멍에 빠지게 하는 최소 횟수를 구하는 문제입니다. 현재 상태에서…","fields":{"slug":"/boj-13460/"},"frontmatter":{"date":"Apr 12, 2020","title":"백준 13460번 - 구슬 탈출 2","tags":["Algorithmn","PS","BOJ","Brute-force","BFS"]}}},{"node":{"rawMarkdownBody":"\n## 문제\nhttps://www.acmicpc.net/problem/15686\n\n## 해설\n최대 2N개의 집이 있을 때, 치킨집 중 M개를 선택하여 집들과 치킨집들 사이 _치킨 거리_ 가 최소가 되도록 구하는 문제입니다. _치킨 거리_ 를 구하는 구체적인 방법은 문제에 기술되어 있습니다.\n\n### 시간복잡도 계산\n$2 \\leq N \\leq 50, 1 \\leq M \\leq 13$ 에서 치킨집은 최대 13개 이하고, 집은 최대 2N개입니다.\n$_{13}\\mathrm{C}_{k} \\leq 1716$ 이므로 최대 uptime은 대략 $1716 \\times 2N \\times M \\leq 10^9$ 로, Brute-force로도 충분히 해결 가능합니다.\n\n### 구현\n입력을 받을 때, 집의 위치와 치킨집의 위치는 따로 vector에 저장해둡니다.\n\n`next_permutation`을 활용해 치킨집들 중에 M개를 선택합니다. 각 경우에 대하여 도시의 _치킨 거리_ 를 구합니다.\n\n## 소스 코드\nhttp://boj.kr/f4b17d380737470296f3ee2fca69f1c8\n\n---\n\n## 참고\n* [`next_permutation`을 사용해 조합 구하기](/ps-reference/#next_permutation)\n* 이 문제에서 _치킨 거리_ 라고 부르는 용어는 사실 [맨해튼 거리](https://ko.wikipedia.org/wiki/%EB%A7%A8%ED%95%B4%ED%8A%BC_%EA%B1%B0%EB%A6%AC)입니다.","excerpt":"문제 https://www.acmicpc.net/problem/15686 해설 최대 2N개의 집이 있을 때, 치킨집 중 M…","fields":{"slug":"/boj-15686/"},"frontmatter":{"date":"Apr 12, 2020","title":"백준 15686번 - 치킨 배달","tags":["Algorithmn","PS","BOJ","Brute-force"]}}},{"node":{"rawMarkdownBody":"\n# Headers\n### bit/stdc++.h\n\n```cpp\n#include <bit/stdc++.h>\n```\n<details>\n<summary>코드 보기</summary>\n<div markdown=\"1\">\n\n```cpp\n// cpp includes used for precompiling -*- cpp -*-\n \n// Copyright (C) 2003-2013 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO cpp Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n \n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n \n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n \n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n \n/** @file stdc++.h\n *  This is an implementation file for a precompiled header.\n */\n \n// 17.4.1.2 Headers\n \n// C\n#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n \n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n \n// cpp\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n \n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n```\n\n</div>\n</details>\n\n\n### ios\n```cpp\n#include <ios>\n#import <ios>\n```\n* 숏코딩용. std I/O 정도만 포함.\n\n\n# Functions\n## 원소를 수정하는 함수\n### sort\n\n```cpp\n#include <algorithm>\nvoid sort(begin, end, [comparator]);\n```\n* 컨테이너 오름차순 정렬.\n* O(NlogN)\n\n```cpp\nsort(vec.begin(), vec.end(), [](const &T a, const &T b){\n    return a < b;\n});\n```\n* 람다식을 이용한 사용자 정의 Comparator 사용.\n* *`comp(a, b) == comp(b, a)`이면 에러 발생, a == b일때는 임의의 순서 배정 필요*\n\n```cpp\n#include <functional>\nsort(vec.begin(), vec.end(), greater<T>());\n```\nfuctional 헤더의 greater Comparator를 사용해 **내림차순 정렬**.\n\n```cpp\nbool operator< (const &T a, const &T b) {\n    return a < b;\n}\n\nsort(vec.begin(), vec.end());\n```\n* 사용자 정의 `<`연산자를 사용.\n* *`sort`는 순서 비교에 `<`만 사용*\n\n\n### reverse\n\n```cpp\n#include <algorithm>\nvoid reverse(begin, end);\n```\n* 컨테이너의 순서 역전\n* O(N)\n\n```cpp(\nreverse(vec.begin(), vec.end());\n```\n\n\n### unique\n\n```cpp\n#include <algorithm>\nT *iter = unique(begin, end);\n```\n* 컨테이너의 중복 요소를 제거. 제거하고 남은 공간은 쓰레기값으로 남고, 쓰레기값의 시작점 이터레이터를 반환.\n* 정렬과 무관하게 연달아 나온 두 원소 중 하나를 제거.\n* O(N)\n\n```cpp\nvec.erase(unique(vec.begin(), vec.end()), vec.end());\n```\n* 컨테이너에서 중복 요소를 제거하고, 남은 쓰레기값을 삭제.\n\n\n### merge\n> *I have never tasted `merge`.*\n\n\n### fill, fill_n\n\n```cpp\n#include <algorithm>\nvoid fill(begin, end, value);\nvoid fill_n(begin, size, value);\n```\n* 컨테이너의 모든 값에 대입. **다차원 배열 불가능**\n* O(N)\n\n```cpp\nfill(vec.begin(), vec.end(), 375);\nfill_n(vec.begin(), vec.size(), 375);\n```\n\n\n### memset\n\n```cpp\n#include <cstring>\nvoid memset(begin, value, size);\n```\n메* 모리에 값을 셋팅. **다차원 배열 가능**\n\n```cpp\nmemset(arr, 0, size(arr));\n```\n* 배열의 모든 값을 0으로 맵핑. \n\n```cpp\nmemset(arr, -1, size(arr));\n```\n* 배열의 모든 값을 0(0xFF)으로 맵핑.\n\n\n## 탐색 관련 함수\n### find (algorithm)\n\n```cpp\n#include <algorithm>\nT *iter = find(begin, end, value);\n```\n* 컨테이너 안에서 값을 찾고 그 이터레이터를 리턴. **없으면 last를 리턴**.\n* O(N)\n\n```cpp\nint x = *find(vec.begin(), vec.end(), 523);\n```\n\n\n### find (string)\n```cpp\n#include <string>\nsize_t pos = str.find(value, [start]);\n```\n* 문자열 안에서 값을 찾고 그 위치를 리턴. **없으면 string::npos(-1)를 리턴**.\n* O(N)\n\n```cpp\nint p = str.find('a');\n```\n* 단일 문자 `'a'`를 찾고 그 위치를 리턴.\n\n```cpp\nint p = str.find(\"aa\");\n```\n* 문자열 `\"aa\"`를 찾고 그 위치를 리턴.\n\n```cpp\nint p = str.find(\"aa\", start);\n```\n* start번째 문자부터 문자열 `\"aa\"`를 찾고 그 위치를 리턴.\n\n\n### binary_search\n\n```cpp\n#include <algorithm>\nbool include = binary_search(begin, end, value, [comparator]);\n```\n* 정렬된 컨테이너에서 값을 탐색하고 찾았는지를 반환.\n* Comparator는 [`sort`](#sort)와 동일.\n* O(logN)\n\n```cpp\nif (binary_search(vec.begin(), vec.end(), 618))\n  cout << \"Find!\";\n```\n\n\n### lower_bound\n\n```cpp\n#include <algorithm>\nT *iter = lower_bound(begin, end, value, [comparator]);\n```\n* 정렬된 컨테이너에서 이진탐색을 하고 찾은 원소의 이터레이터를 반환, 못 찾으면 value보다 큰 값(다음 위치)의 이터레이터를 반환.\n* $$[0, pivot]$$ 에서 가장 작은 값의 이터레이터.\n* Comparator는 [`sort`](#sort)와 동일.\n* O(logN)\n\n\n### upper_bound\n\n```cpp\n#include <algorithm>\nT *iter = upper_bound(begin, end, value, [comparator]);\n```\n* 정렬된 컨테이너에서 이진탐색을 하고 value를 초과하는 값의 이터레이터를 반환.\n* $$(pivot, N]$$ 에서 가장 작은 값의 이터레이터.\n* Comparator는 [`sort`](#sort)와 동일.\n* O(logN)\n\n\n### equal_range\n\n```cpp\n#include <algorithm>\npair<T*, T*> iterPair = equal_range(begin, end, value, [comparator]);\n```\n* 정렬된 컨테이너에서 이진탐색을 하고 lower_bound와 upper_bound를 pair로 반환.\n* $$[lower\\_bound, upper\\_bound)$$ 범위 이터레이터 리턴.\n* Comparator는 [`sort`](#sort)와 동일.\n* O(logN)\n\n```cpp\nauto p = equal_range(vec.begin(), vec.end(), 762);\ncout << distance(p.first, p.second); // == (p.second - p.first)\n```\n이진탐색을 하고 value와 일치하는 원소의 갯수를 출력. `count(LB ≤ value < RB)`\n\n\n## 수학 관련 함수\n### min, max\n\n```cpp\n#include <algorithm>\nT min(a, b, [comparator]);\nT min(init_list, [comparator]);\nT max(a, b, [comparator]);\nT max(init_list, [comparator]);\n```\n* 매개변수의 최솟값이나 최댓값을 반환.\n* Comparator는 [`sort`](#sort)와 동일.\n\n```cpp\nint mn = min({ 3, 4, 5 });\nint mx = max({ 3, 4, 5 });\n```\n`initializer_list`를 사용하여 최솟값/최댓값 반환.\n\n\n### min&#95;element, max&#95;element\n\n```cpp\n#include <algorithm>\nT *iter = min_element(a, b, [comparator]);\nT *iter = min_element(init_list, [comparator]);\nT *iter = max_element(a, b, [comparator]);\nT *iter = max_element(init_list, [comparator]);\n```\n* 매개변수의 최솟값이나 최댓값의 이터레이터를 반환.\n* Comparator는 [`sort`](#sort)와 동일.\n\n```cpp\nint mn = *min_element({ 3, 4, 5 });\nint mx = *max_element({ 3, 4, 5 });\n```\n`initializer_list`를 사용하여 최솟값/최댓값의 이터레이터를 반환.\n\n\n### ceil, round, floor\n\n```cpp\n#include <cmath>\nT ceil(value);\nT round(value);\nT floor(value);\n```\n* `ceil`: value보다 큰 가장 가까운 정수로 올림\n* `round`: value와 가장 가까운 정수로 반올림\n* `floor`: value보다 작은 가장 가까운 정수로 내림\n\n```cpp\nint H = (int)ceil(log2(N));\nint tree_size = 1 << (H+1);\n```\n`ceil`를 사용하여 트리의 노드 수를 구함.\n\n\n### next_permutation\n\n```cpp\n#include <algorithm>\nbool next_permutation(begin, end, [comparator]);\n```\n* 컨테이너 순열의 다음 번째 순열로 변환, 더 이상 진행할 수 없으면(내림차순 순열이면) `false` 반환.\n* 2종류의 원소만 사용한 배열을 사용하면 조합을 구할 수도 있다.\n* Comparator는 [`sort`](#sort)와 동일.\n\n```cpp\ndo {\n  // ...\n} while (next_permutation(vec.begin(), vec.end()));\n```\n\n```cpp\n// 5C2 구하기\nvector<int> vec(5);\nvector<bool> filter = { false, false, false, true, true };\ndo {\n  for (int i = 0; i < 5; ++i) {\n    if (filter[i]) {\n      // vec[i] is selected.\n    }\n  }\n} while (next_permutation(filter.begin(), filter.end()));\n```\n중복되는 원소를 가진 `filter`의 순열을 구하고, 여기에 대응되는 `vec`의 원소를 선택해서 중복을 허용한다.\n\n\n### prev_permutation\n\n```cpp\n#include <algorithm>\nbool prev_permutation(begin, end, [comparator]);\n```\n* 컨테이너 순열의 이전 번째 순열로 변환, 더 이상 진행할 수 없으면(오름차순 순열이면) `false` 반환.\n* 2종류의 원소만 사용한 배열을 사용하면 조합을 구할 수도 있다.\n* Comparator는 [`sort`](#sort)와 동일.\n\n```cpp\ndo {\n  // ...\n} while (prev_permutation(vec.begin(), vec.end()));\n```\n\n```cpp\n// 5C2 구하기\nvector<int> vec(5);\nvector<bool> filter = { false, false, false, true, true };\ndo {\n  for (int i = 0; i < 5; ++i) {\n    if (filter[i]) {\n      // vec[i] is selected.\n    }\n  }\n} while (prev_permutation(filter.begin(), filter.end()));\n```\n중복되는 원소를 가진 `filter`의 순열을 구하고, 여기에 대응되는 `vec`의 원소를 선택해서 중복을 허용한다.\n\n\n### &#95;&#95;builtin&#95;popcount\n\n```cpp\nunsigned int __builtin_popcount(uint32 value);\n```\n* 32bit unsigned int에 대하여, 1인 bit의 수를 반환.\n* ⚠️ **GCC환경에서만 동작.** ⚠️\n* bitmasking에 대한 더 자세한 내용은 다른 포스트로 추가 예정.\n<!--\n더 공부해보고 정리해서 추가하기\n[Count bits 1 on an integer as fast as GCC __builtin__popcount(int) - Stack Overflow](https://stackoverflow.com/questions/51387998/count-bits-1-on-an-integer-as-fast-as-gcc-builtin-popcountint)\n[마크다운으로 주석 처리 가능](http://www.secmem.org/blog/2019/10/19/handy-function-about-bit/)\n[비트마스크 사용법](https://sunnyholic.com/88)\n-->\n\n\n---\n\nReferences\n* http://www.cplusplus.com/\n* https://en.cppreference.com/","excerpt":"Headers bit/stdc++.h ios 숏코딩용. std I/O 정도만 포함. Functions 원소를 수정하는 함수 sort 컨테이너 오름차순 정렬. O(NlogN) 람다식을 이용한 사용자 정의 Comparator 사용. 이면 에러 발생, a…","fields":{"slug":"/ps-reference/"},"frontmatter":{"date":"Mar 01, 2020","title":"모르면 못푸는 PS용 C++ 레퍼런스","tags":["Algorithmn","PS","STL"]}}},{"node":{"rawMarkdownBody":"\n# 1. Install jenv\n\n```bash\nbrew install jenv\n```\n`brew`를 사용해서 jenv를 설치한다.\n\n\n```bash\nexport PATH=\"$HOME/.jenv/bin:$PATH\"\nif which jenv > /dev/null; then eval \"$(jenv init -)\"; fi\n```\njenv의 환경변수를 설정한다.\n`.bash_profile` 또는 `.zshrc`에 위 코드를 추가한다.\n\n\n```bash\nsource ~/.bash_profile\nsource ~/.zshrc\n```\n`.bash_profile` 또는 `.zshrc`를 실행하여 설정을 적용한다.\n\n\n```bash\njenv enable-plugin export\n```\njenv의 Export plugin을 설정한다.\n`$JAVA_HOME`등의 가상환경으로 연결을 설정한다.\n\n정상적으로 설정이 완료되었다면, `which java`를 했을 때, `$HOME/.jenv/shims/java`로 경로가 나온다.\n\n\n# 2. Install JDK\nJDK를 설치한다.\n`brew`를 사용해도 좋고, Oracle이나 OpenJDK 홈페이지에 접속해서 pkg파일을 다운로드 받은 뒤 설치해도 좋다.\n\n\n# 3. Register JDK to jenv\n```bash\njenv add /Library/Java/JavaVirtualMachines/[JDK version name]/Contents/Home/\n```\n설치한 JDK를 jenv에 등록한다.\n\n# 4. Use jenv\n  * `jenv versions` : 사용할 수 있는 JDK 환경 목록을 보여준다.\n  * `jenv global [JDK version name]` : 선택한 JDK 환경을 기본 설정으로 사용한다.\n  * `jenv local [JDK version name]` : 현재 디렉토리에서만 선택한 JDK 환경을 사용한다.","excerpt":"1. Install jenv 를 사용해서 jenv를 설치한다. jenv의 환경변수를 설정한다.\n 또는 에 위 코드를 추가한다.  또는 를 실행하여 설정을 적용한다. jenv의 Export plugin…","fields":{"slug":"/jenv-on-mac/"},"frontmatter":{"date":"Feb 29, 2020","title":"macOS에서 jenv 사용하기","tags":["Java","macOS"]}}}]}},"pageContext":{}}}