{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n# Headers\n### bit/stdc++.h\n\n```cpp\n#include <bit/stdc++.h>\n```\n<details>\n<summary>코드 보기</summary>\n<div markdown=\"1\">\n\n```cpp\n// cpp includes used for precompiling -*- cpp -*-\n \n// Copyright (C) 2003-2013 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO cpp Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n \n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n \n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n \n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n \n/** @file stdc++.h\n *  This is an implementation file for a precompiled header.\n */\n \n// 17.4.1.2 Headers\n \n// C\n#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n \n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n \n// cpp\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n \n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n```\n\n</div>\n</details>\n\n\n### ios\n```cpp\n#include <ios>\n#import <ios>\n```\n* 숏코딩용. std I/O 정도만 포함.\n\n\n# Functions\n## 원소를 수정하는 함수\n### sort\n\n```cpp\n#include <algorithm>\nvoid sort(begin, end, [comparator]);\n```\n* 컨테이너 오름차순 정렬.\n* O(NlogN)\n\n```cpp\nsort(vec.begin(), vec.end(), [](const &T a, const &T b){\n    return a < b;\n});\n```\n* 람다식을 이용한 사용자 정의 Comparator 사용.\n* *`comp(a, b) == comp(b, a)`이면 에러 발생, a == b일때는 임의의 순서 배정 필요*\n\n```cpp\n#include <functional>\nsort(vec.begin(), vec.end(), greater<T>());\n```\nfuctional 헤더의 greater Comparator를 사용해 **내림차순 정렬**.\n\n```cpp\nbool operator< (const &T a, const &T b) {\n    return a < b;\n}\n\nsort(vec.begin(), vec.end());\n```\n* 사용자 정의 `<`연산자를 사용.\n* *`sort`는 순서 비교에 `<`만 사용*\n\n\n### reverse\n\n```cpp\n#include <algorithm>\nvoid reverse(begin, end);\n```\n* 컨테이너의 순서 역전\n* O(N)\n\n```cpp(\nreverse(vec.begin(), vec.end());\n```\n\n\n### unique\n\n```cpp\n#include <algorithm>\nT *iter = unique(begin, end);\n```\n* 컨테이너의 중복 요소를 제거. 제거하고 남은 공간은 쓰레기값으로 남고, 쓰레기값의 시작점 이터레이터를 반환.\n* 정렬과 무관하게 연달아 나온 두 원소 중 하나를 제거.\n* O(N)\n\n```cpp\nvec.erase(unique(vec.begin(), vec.end()), vec.end());\n```\n* 컨테이너에서 중복 요소를 제거하고, 남은 쓰레기값을 삭제.\n\n\n### merge\n> *I have never tasted `merge`.*\n\n\n### fill, fill_n\n\n```cpp\n#include <algorithm>\nvoid fill(begin, end, value);\nvoid fill_n(begin, size, value);\n```\n* 컨테이너의 모든 값에 대입. **다차원 배열 불가능**\n* O(N)\n\n```cpp\nfill(vec.begin(), vec.end(), 375);\nfill_n(vec.begin(), vec.size(), 375);\n```\n\n\n### memset\n\n```cpp\n#include <cstring>\nvoid memset(begin, value, size);\n```\n메* 모리에 값을 셋팅. **다차원 배열 가능**\n\n```cpp\nmemset(arr, 0, size(arr));\n```\n* 배열의 모든 값을 0으로 맵핑. \n\n```cpp\nmemset(arr, -1, size(arr));\n```\n* 배열의 모든 값을 0(0xFF)으로 맵핑.\n\n\n## 탐색 관련 함수\n### find (algorithm)\n\n```cpp\n#include <algorithm>\nT *iter = find(begin, end, value);\n```\n* 컨테이너 안에서 값을 찾고 그 이터레이터를 리턴. **없으면 last를 리턴**.\n* O(N)\n\n```cpp\nint x = *find(vec.begin(), vec.end(), 523);\n```\n\n\n### find (string)\n```cpp\n#include <string>\nsize_t pos = str.find(value, [start]);\n```\n* 문자열 안에서 값을 찾고 그 위치를 리턴. **없으면 string::npos(-1)를 리턴**.\n* O(N)\n\n```cpp\nint p = str.find('a');\n```\n* 단일 문자 `'a'`를 찾고 그 위치를 리턴.\n\n```cpp\nint p = str.find(\"aa\");\n```\n* 문자열 `\"aa\"`를 찾고 그 위치를 리턴.\n\n```cpp\nint p = str.find(\"aa\", start);\n```\n* start번째 문자부터 문자열 `\"aa\"`를 찾고 그 위치를 리턴.\n\n\n### binary_search\n\n```cpp\n#include <algorithm>\nbool include = binary_search(begin, end, value, [comparator]);\n```\n* 정렬된 컨테이너에서 값을 탐색하고 찾았는지를 반환.\n* Comparator는 [`sort`](#sort)와 동일.\n* O(logN)\n\n```cpp\nif (binary_search(vec.begin(), vec.end(), 618))\n  cout << \"Find!\";\n```\n\n\n### lower_bound\n\n```cpp\n#include <algorithm>\nT *iter = lower_bound(begin, end, value, [comparator]);\n```\n* 정렬된 컨테이너에서 이진탐색을 하고 찾은 원소의 이터레이터를 반환, 못 찾으면 value보다 큰 값(다음 위치)의 이터레이터를 반환.\n* $$[0, pivot]$$ 에서 가장 작은 값의 이터레이터.\n* Comparator는 [`sort`](#sort)와 동일.\n* O(logN)\n\n\n### upper_bound\n\n```cpp\n#include <algorithm>\nT *iter = upper_bound(begin, end, value, [comparator]);\n```\n* 정렬된 컨테이너에서 이진탐색을 하고 value를 초과하는 값의 이터레이터를 반환.\n* $$(pivot, N]$$ 에서 가장 작은 값의 이터레이터.\n* Comparator는 [`sort`](#sort)와 동일.\n* O(logN)\n\n\n### equal_range\n\n```cpp\n#include <algorithm>\npair<T*, T*> iterPair = equal_range(begin, end, value, [comparator]);\n```\n* 정렬된 컨테이너에서 이진탐색을 하고 lower_bound와 upper_bound를 pair로 반환.\n* $$[lower\\_bound, upper\\_bound)$$ 범위 이터레이터 리턴.\n* Comparator는 [`sort`](#sort)와 동일.\n* O(logN)\n\n```cpp\nauto p = equal_range(vec.begin(), vec.end(), 762);\ncout << distance(p.first, p.second); // == (p.second - p.first)\n```\n이진탐색을 하고 value와 일치하는 원소의 갯수를 출력. `count(LB ≤ value < RB)`\n\n\n## 수학 관련 함수\n### min, max\n\n```cpp\n#include <algorithm>\nT min(a, b, [comparator]);\nT min(init_list, [comparator]);\nT max(a, b, [comparator]);\nT max(init_list, [comparator]);\n```\n* 매개변수의 최솟값이나 최댓값을 반환.\n* Comparator는 [`sort`](#sort)와 동일.\n\n```cpp\nint mn = min({ 3, 4, 5 });\nint mx = max({ 3, 4, 5 });\n```\n`initializer_list`를 사용하여 최솟값/최댓값 반환.\n\n\n### min&#95;element, max&#95;element\n\n```cpp\n#include <algorithm>\nT *iter = min_element(a, b, [comparator]);\nT *iter = min_element(init_list, [comparator]);\nT *iter = max_element(a, b, [comparator]);\nT *iter = max_element(init_list, [comparator]);\n```\n* 매개변수의 최솟값이나 최댓값의 이터레이터를 반환.\n* Comparator는 [`sort`](#sort)와 동일.\n\n```cpp\nint mn = *min_element({ 3, 4, 5 });\nint mx = *max_element({ 3, 4, 5 });\n```\n`initializer_list`를 사용하여 최솟값/최댓값의 이터레이터를 반환.\n\n\n### ceil, round, floor\n\n```cpp\n#include <cmath>\nT ceil(value);\nT round(value);\nT floor(value);\n```\n* `ceil`: value보다 큰 가장 가까운 정수로 올림\n* `round`: value와 가장 가까운 정수로 반올림\n* `floor`: value보다 작은 가장 가까운 정수로 내림\n\n```cpp\nint H = (int)ceil(log2(N));\nint tree_size = 1 << (H+1);\n```\n`ceil`를 사용하여 트리의 노드 수를 구함.\n\n\n### next_permutation\n\n```cpp\n#include <algorithm>\nbool next_permutation(begin, end, [comparator]);\n```\n* 컨테이너 순열의 다음 번째 순열로 변환, 더 이상 진행할 수 없으면(내림차순 순열이면) `false` 반환.\n* Comparator는 [`sort`](#sort)와 동일.\n\n```cpp\ndo {\n  // ...\n} while (next_permutation(vec.begin(), vec.end()));\n```\n\n\n### prev_permutation\n\n```cpp\n#include <algorithm>\nbool prev_permutation(begin, end, [comparator]);\n```\n* 컨테이너 순열의 이전 번째 순열로 변환, 더 이상 진행할 수 없으면(오름차순 순열이면) `false` 반환.\n* Comparator는 [`sort`](#sort)와 동일.\n\n```cpp\ndo {\n  // ...\n} while (prev_permutation(vec.begin(), vec.end()));\n```\n\n\n### &#95;&#95;builtin&#95;popcount\n\n```cpp\nunsigned int __builtin_popcount(uint32 value);\n```\n* 32bit unsigned int에 대하여, 1인 bit의 수를 반환.\n* ⚠️ **GCC환경에서만 동작.** ⚠️\n* bitmasking에 대한 더 자세한 내용은 다른 포스트로 추가 예정.\n<!--\n더 공부해보고 정리해서 추가하기\n[Count bits 1 on an integer as fast as GCC __builtin__popcount(int) - Stack Overflow](https://stackoverflow.com/questions/51387998/count-bits-1-on-an-integer-as-fast-as-gcc-builtin-popcountint)\n[마크다운으로 주석 처리 가능](http://www.secmem.org/blog/2019/10/19/handy-function-about-bit/)\n[비트마스크 사용법](https://sunnyholic.com/88)\n-->\n\n\n---\n\nReferences\n* http://www.cplusplus.com/\n* https://en.cppreference.com/","excerpt":"Headers bit/stdc++.h ios 숏코딩용. std I/O 정도만 포함. Functions 원소를 수정하는 함수 sort 컨테이너 오름차순 정렬. O(NlogN) 람다식을 이용한 사용자 정의 Comparator 사용. 이면 에러 발생, a…","fields":{"slug":"/ps-reference/"},"frontmatter":{"date":"Mar 01, 2020","title":"모르면 못푸는 PS용 C++ 레퍼런스","tags":["Algorithmn","PS","STL"]}}},{"node":{"rawMarkdownBody":"\n# 1. Install jenv\n\n```bash\nbrew install jenv\n```\n`brew`를 사용해서 jenv를 설치한다.\n\n\n```bash\nexport PATH=\"$HOME/.jenv/bin:$PATH\"\nif which jenv > /dev/null; then eval \"$(jenv init -)\"; fi\n```\njenv의 환경변수를 설정한다.\n`.bash_profile` 또는 `.zshrc`에 위 코드를 추가한다.\n\n\n```bash\nsource ~/.bash_profile\nsource ~/.zshrc\n```\n`.bash_profile` 또는 `.zshrc`를 실행하여 설정을 적용한다.\n\n\n```bash\njenv enable-plugin export\n```\njenv의 Export plugin을 설정한다.\n`$JAVA_HOME`등의 가상환경으로 연결을 설정한다.\n\n정상적으로 설정이 완료되었다면, `which java`를 했을 때, `$HOME/.jenv/shims/java`로 경로가 나온다.\n\n\n# 2. Install JDK\nJDK를 설치한다.\n`brew`를 사용해도 좋고, Oracle이나 OpenJDK 홈페이지에 접속해서 pkg파일을 다운로드 받은 뒤 설치해도 좋다.\n\n\n# 3. Register JDK to jenv\n```bash\njenv add /Library/Java/JavaVirtualMachines/[JDK version name]/Contents/Home/\n```\n설치한 JDK를 jenv에 등록한다.\n\n# 4. Use jenv\n  * `jenv versions` : 사용할 수 있는 JDK 환경 목록을 보여준다.\n  * `jenv global [JDK version name]` : 선택한 JDK 환경을 기본 설정으로 사용한다.\n  * `jenv local [JDK version name]` : 현재 디렉토리에서만 선택한 JDK 환경을 사용한다.","excerpt":"1. Install jenv 를 사용해서 jenv를 설치한다. jenv의 환경변수를 설정한다.\n 또는 에 위 코드를 추가한다.  또는 를 실행하여 설정을 적용한다. jenv의 Export plugin…","fields":{"slug":"/jenv-on-mac/"},"frontmatter":{"date":"Feb 29, 2020","title":"macOS에서 jenv 사용하기","tags":["Java","macOS"]}}}]}},"pageContext":{}}}